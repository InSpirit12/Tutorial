# 作用域链

## 作用域链的定义
scope的概念  
作用域的存储方式是栈，后进先出，销毁也是按照栈的方式

## 闭包
`官方定义`：闭包(Closure)是词法闭包(Lexical Closure)的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外  
闭包其实就是作用域的扩展与对象销毁的知识点，当一个对象被调用时会优先在自身作用域搜索，如果没找到再去上层作用域搜索，直到搜索到全局，若还没找到则返回null  
当一个函数调用了外部对象，且外部对象执行完毕后，理论上外部对象的属性和方法都应该被回收，但如果有其它函数引用了属性和方法，该变量所占内存将不会被释放  
`注意1`：如果闭包调用的是基本类型，按照按值传递的方法，该属性会复制一份到闭包中，如果调用的是对象，按照指针引用方法，内存空间始终是运行时开辟的那块   
`注意2`：过度使用闭包会占用更多内存，故意使用可以使内存溢出  
`闭包的副作用`：  
```
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i); //输出5,5,5,5,5
  }, 5);
}
```
结果输出5个5，是因为 setTimeout 中的 i 是对外层 i 的引用。当 setTimeout 的代码被解释的时候，运行时只是记录了 i 的引用，而不是值。而当 setTimeout 被触发时，五个 setTimeout 中的 i 同时被取值，由于它们都指向了外层的同一个 i，而那个 i 的值在迭代完成时为 5，所以打印了5个5，可以把 i 赋值成一个局部的变量，从而摆脱外层迭代的影响：  
```
for (var i = 0; i < 5; i++) {
  (function (idx) {
    setTimeout(function () {
      console.log(idx);
    }, 5);
  })(i);
}
```
