# function对象

## function基础
function是一个object对象,所以继承了Object中的属性与方法  
函数内部有arguments和this两个对象，arguments是个类数组对象（不是array的实例但功能相似），存储了函数的所有参数，this指向调用该function的作用域  
function没有重载，后定义的函数会覆盖先定义的函数，但可以通过判断arguments.length，typeof（参数）的方法来模拟重载，不过也没什么必要  

## 函数声明与函数表达式
函数声明：  
解析器会优先解析函数声明，所以函数声明会被提升，可以在任何文件定义和引用而不必担心引用失败报错  
```
console.log(sum); //不会报错
function sum () {
  return 1;
}
```

函数表达式：  
```
console.log(sum); //会报错
var sum = function () {
  return 1;
}
console.log(sum); //不会报错
```
## 函数属性与方法
非继承方法call，apply，设置this对象的值  
区别：  
```
call(this, num1, num2...);
apply(this, [num1, num2...]);
```
## 闭包
`官方定义`：闭包(Closure)是词法闭包(Lexical Closure)的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外  
闭包其实就是作用域的扩展与对象销毁的知识点，当一个对象被调用时会优先在自身作用域搜索，如果没找到再去上层作用域搜索，直到搜索到全局，若还没找到则返回null  
当一个函数调用了外部对象，且外部对象执行完毕后，理论上外部对象的属性和方法都应该被回收，但如果有其它函数引用了属性和方法，该变量所占内存将不会被释放（将被引属性和方法拷贝一份到其他函数中？还是没有拷贝，只是引用，所以内存空间始终是运行时开辟的那块？）  
`注意`：过度使用闭包会占用更多内存，合理使用可以使内存溢出  
